%----------------------Declare matrices for the solver--------------------%
%Time-level: n arrays
rho = zeros(N,N);
u = zeros(N,N);
v = zeros(N,N);
p = zeros(N,N);
%Time-level:n+1 arrays
rho n = zeros(N,N);
u n = zeros(N,N);
v n = zeros(N,N);
p n = zeros(N,N);
%matrices for storing norms
u norm = [];
v norm = [];
rho norm = [];
p norm = [];
time = [];
%--------------------Initial conditions-------------------------------%
%freestream conditions
M=6;
gamma = 1.4;
p inflow = 1/gamma;
rho inflow=1;
u inflow = M*sqrt(gamma*p inflow/rho inflow);
cfl=0.5;

 %Initialize
 for i=1:N
 for j=1:N
 u(i,j)= u inflow;
 p(i,j)=p inflow;
 rho(i,j)=rho inflow;
 v(i,j)=0;
 end
 end
 %------------------Main Solution Loop--------------------------------%
 %set time:
 t=0;
 %set max time of simulation:
 t max=10;


 %Solve:
 %Index notation followed: i for xi direction, j for eta direction
 while(t<t max)
 %compute minimum dt:
 dt min = cfl*compute dt(u,v,p,rho, xi x, xi y, eta x, eta y, dxi, deta);

 %advance i=1 and i=N, in the interior j's
 % For i=1, i+1=2, i-1 = N-1
 for j=2:N-1
 %Compute RHS
 R ij =(F plus(u(1,j),...
 v(1,j),...
 p(1,j),...
 rho(1,j),...
 xi x(1,j),...
 xi y(1,j),...
 J(1,j))...
 -F plus(u(N-1,j),...
 v(N-1,j),...
 p(N-1,j),...
 rho(N-1,j),...
 xi x(N-1,j),...
 xi y(N-1,j),...
 J(N-1,j)))/dxi...
 +(F minus(u(2,j),...
 v(2,j),...
 p(2,j),...
 rho(2,j),...
 xi x(2,j),...
 xi y(2,j),...
 J(2,j))...
 -F minus(u(1,j),...
 v(1,j),...
 p(1,j),...
 rho(1,j),...
 xi x(1,j),...
 xi y(1,j),...
 J(1,j)))/dxi...
 +(F plus(u(1,j),
 v(1,j),...
 p(1,j),...
 rho(1,j),...
 eta x(1,j),...
 eta y(1,j),...
 J(1,j))...
 -F plus(u(1,j-1),...
 v(1,j-1),...
 p(1,j-1),...
 rho(1,j-1),...
 eta x(1,j-1),...
 eta y(1,j-1),...
 J(1,j-1)))/deta...
 +(F minus(u(1,j+1),...
 v(1,j+1),...
 p(1,j+1),...
 rho(1,j+1),...
 eta x(1,j+1),...
 eta y(1,j+1),...
 J(1,j+1))...

 -F minus(u(1,j),...
 v(1,j),...
 p(1,j),...
 rho(1,j),...
 eta x(1,j),...
 eta y(1,j),...
 J(1,j)))/deta;

 %Locally construct conserved state vector
 U old = [rho(1,j);...
 rho(1,j)*u(1,j);...
 rho(1,j)*v(1,j);...
 rho(1,j)*(0.5*u(1,j)ˆ2+0.5*v(1,j)ˆ2)+p(1,j)/(gamma-1)];

 %advance
 U new = U old -dt min*J(1,j)*R ij;

 %get back new primitive vars
 rho new = U new(1);
 u new = U new(2)/rho new;
 v new = U new(3)/rho new;
 q new = 0.5*(u newˆ2+v newˆ2);
 p new = (gamma-1)*(U new(4)-rho new*q new);

 %assign to new arrays
 % since xi-direction is periodic, we note i=1 and i=N are the same
 rho n(1,j) = rho new;
 rho n(N,j) = rho new;
 u n(1,j) = u new;
 u n(N,j) = u new;
 v n(1,j) = v new;
 v n(N,j) = v new;
 p n(1,j) = p new;
 p n(N,j) = p new;
 end

 %advance all other interior j's and i's i.e. 2:N-1
 for j=2:N-1 %iterate through the interior ellipses-outer loop, we will fill ...
, N later
 for i=2:N-1 %iterate along the interior ellipses-inner loop, we will fill ...
,N later
 %compute RHS
 R ij =(F plus(u(i,j),
 v(i,j),...
 p(i,j),...
 rho(i,j),...
 xi x(i,j),...
 xi y(i,j),...
 J(i,j))...
 -F plus(u(i-1,j),...
 v(i-1,j),...
 p(i-1,j),...
 rho(i-1,j),...
 xi x(i-1,j),...
 xi y(i-1,j),...
 J(i-1,j)))/dxi...
 +(F minus(u(i+1,j),...
 v(i+1,j),...
 p(i+1,j),...
 rho(i+1,j),...

 xi x(i+1,j),...
 xi y(i+1,j),...
 J(i+1,j))...
 -F minus(u(i,j),...
 v(i,j),...
 p(i,j),...
 rho(i,j),...
 xi x(i,j),...
 xi y(i,j),...
 J(i,j)))/dxi...
 +(F plus(u(i,j),...
 v(i,j),...
 p(i,j),...
 rho(i,j),...
 eta x(i,j),...
 eta y(i,j),...
 J(i,j))...
 -F plus(u(i,j-1),...
 v(i,j-1),...
 p(i,j-1),...
 rho(i,j-1),...
 eta x(i,j-1),...
 eta y(i,j-1),...
 J(i,j-1)))/deta...
 +(F minus(u(i,j+1),...
 v(i,j+1),...
 p(i,j+1),...
 rho(i,j+1),...
 eta x(i,j+1),...
 eta y(i,j+1),...
 J(i,j+1))...
 -F minus(u(i,j),...
 v(i,j),...
 p(i,j),...
 rho(i,j),...
 eta x(i,j),...
 eta y(i,j),...
 J(i,j)))/deta;

 %construct U old
 U old = [rho(i,j);...
 rho(i,j)*u(i,j);...
 rho(i,j)*v(i,j);...
 0.5*rho(i,j)*(u(i,j)ˆ2+v(i,j)ˆ2)+p(i,j)/(gamma-1)];

 %advance
 U new = U old -dt min*J(i,j)*R ij;

 %extract fields from solution
 rho new = U new(1);
 u new = U new(2)/rho new;
 v new = U new(3)/rho new;
 q new = 0.5*(u newˆ2+v newˆ2);
 p new = (gamma-1)*(U new(4)-rho new*q new);

 %assign to new arrays:
 rho n(i,j) = rho new;
 u n(i,j) = u new;
 v n(i,j) = v new;
 p n(i,j) = p new;

 end
 end

 %advance j=1 and j=N
 for i=1:N
 %j=1 i.e. airfoil surface
 M = [xi x(i,1) xi y(i,1);eta x(i,1) eta y(i,1)];
 D = [xi x(i,2)*u n(i,2)+xi y(i,2)*v n(i,2); 0];
 A=M\D;
 %get velocities
 u n(i,1)= A(1); v n(i,1)=A(2);
 %get density
 rho n(i,1) = rho n(i,2);
 %get pressure
 q 1 = 0.5*(u n(i,1)ˆ2 + v n(i,1)ˆ2);
 q 2 = 0.5*(u n(i,2)ˆ2 + v n(i,2)ˆ2);
 p n(i,1) = p n(i,2) + (gamma-1)*(rho n(i,2)*q 2-rho n(i,1)*q 1);

 %j=N, i.e. outer boundary
 if(i>N/2 && i≤3*N/2)
 %one half of the domain is an inlet
 u n(i,N)=u inflow;
 v n(i,N)=0;
 p n(i,N)=p inflow;
 rho n(i,N)=rho inflow;
 else
 %other half is an outlet
 u n(i,N)=u n(i,N-1);
 v n(i,N)=v n(i,N-1);
 p n(i,N)=p n(i,N-1);
 rho n(i,N)=rho n(i,N-1);
 end
 end

 %impose periodicity along i once again
 u n(N,:)=u n(1,:);
 v n(N,:)=v n(1,:);
 p n(N,:)=p n(1,:);
 rho n(N,:)=rho n(1,:);

 %compute norms
 L2 u = norm(u-u n,2);
 L2 v = norm(v-v n,2);
 L2 p = norm(p-p n,2);
 L2 rho = norm(rho-rho n,2);

 %update norm vectors
 u norm = [L2 u, u norm];
 v norm = [L2 v, v norm];
 p norm = [L2 p, p norm];
 rho norm = [L2 rho, rho norm];

 %update solution arrays
 u = u n;
 v = v n;
 p = p n;
 rho = rho n;

 %advance time
 t = t+dt min;

 %display time
 t
 %store time
 time = [t,time];
 end

 %plot residuals of primitive variables vs time
 loglog(time,p norm,...
 time,rho norm,...
 time,u norm,...
 time,v norm);
 xlabel("time");legend("pressure","rho","u","v")